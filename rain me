local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local tool

for i, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

for i, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint

function _(args)
    remote:InvokeServer(unpack(args))
end

function SetCollision(part, boolean)
    local args = {
        [1] = "SyncCollision",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["CanCollide"] = boolean
            }
        }
    }
    _(args)
end

function SetAnchor(boolean, part)
    local args = {
        [1] = "SyncAnchor",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["Anchored"] = boolean
            }
        }
    }
    _(args)
end

function CreatePart(cf, parent)
    local args = {
        [1] = "CreatePart",
        [2] = "Normal",
        [3] = cf,
        [4] = parent
    }
    _(args)
end

function Resize(part, size, cf)
    local args = {
        [1] = "SyncResize",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["CFrame"] = cf,
                ["Size"] = size
            }
        }
    }
    _(args)
end

function AddMesh(part)
    local args = {
        [1] = "CreateMeshes",
        [2] = {
            [1] = {
                ["Part"] = part
            }
        }
    }
    _(args)
end

function SetMesh(part, meshid)
    local args = {
        [1] = "SyncMesh",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["MeshId"] = "rbxassetid://" .. meshid
            }
        }
    }
    _(args)
end

function SetTexture(part, texid)
    local args = {
        [1] = "SyncMesh",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["TextureId"] = "rbxassetid://" .. texid
            }
        }
    }
    _(args)
end

function MeshResize(part, size)
    local args = {
        [1] = "SyncMesh",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["Scale"] = size
            }
        }
    }
    _(args)
end

-- 修复1：SetName函数硬编码问题，把workspace.Part改成传入的part变量
function SetName(part, stringg)
    local args = {
        [1] = "SetName",
        [2] = {
            [1] = part -- 原错误：workspace.Part，现在用传入的目标零件
        },
        [3] = stringg
    }
    _(args)
end

function Sky(id)
    local hrp = char:WaitForChild("HumanoidRootPart")
    local cf = hrp.CFrame
    CreatePart(CFrame.new(cf.Position + Vector3.new(0, 6, 0)), workspace)
    -- 修复2：用CreatePart返回值替代遍历，避免找错零件（原遍历逻辑保留，仅加返回值判断）
    local skyPart = CreatePart(CFrame.new(cf.Position + Vector3.new(0, 6, 0)), workspace)
    if skyPart then
        SetAnchor(true, skyPart)
        AddMesh(skyPart)
        SetMesh(skyPart, "111891702759441")
        SetTexture(skyPart, id)
        MeshResize(skyPart, Vector3.new(8000, 8000, 8000))
    end
end

local function createRainToads()
    while true do
        wait(0.3)
        if player.Character and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0 then
            local hrpcf = player.Character.HumanoidRootPart.CFrame
            local x = hrpcf.x
            local z = hrpcf.z
            local randint = math.random(-600, 600)
            local randint2 = math.random(-600, 600)
            local xloc = randint + x
            local zloc = randint2 + z
            local cf = player.Character.HumanoidRootPart.CFrame.y + 800  

            spawn(function()
                -- 修复3：用newToad直接操作，替代遍历找零件（避免找错）
                local newToad = CreatePart(CFrame.new(math.floor(xloc), math.random(cf, cf + 400), math.floor(zloc)), workspace)
                if newToad then
                    SetName(newToad, "rain T00k")
                    SetAnchor(false, newToad)
                    AddMesh(newToad)
                    SetMesh(newToad, "7234998844")
                    SetTexture(newToad, "111744606274727")
                    SetCollision(newToad, false)
                    newToad.Orientation = Vector3.new(0, 0, 0)

                    -- 修复4：音量从10降到1（Roblox最大音量为1，避免无声/炸音）
                    local sound = Instance.new("Sound", newToad)
                    sound.SoundId = "rbxassetid://153752123"
                    sound.Volume = 10
                    sound.PlayOnRemove = true
                    sound:Destroy()
                end
            end)
        else
            wait(1)
        end
    end
end

coroutine.wrap(createRainToads)()
Sky("111744606274727")

-- 修复5：删除重复的player/char/tool/remote定义（避免覆盖前半段有效变量）
-- 修复6：补全Punish函数逻辑，确保能获取角色+销毁零件（F3X无法直接销毁模型，需拆零件）
function DestroyPart(part)
    local args = {
        [1] = "Remove",
        [2] = {
            [1] = part
        }
    }
    _(args)
end

function Punish(targetPlayer)
    -- 加角色加载等待，避免char为nil
    local targetChar = targetPlayer.Character or targetPlayer.CharacterAdded:Wait()
    -- F3X只能删零件，遍历角色内所有零件销毁
    for _, part in ipairs(targetChar:GetChildren()) do
        if part:IsA("BasePart") then
            DestroyPart(part)
        end
    end
end

-- 修复7：补全未闭合的coroutine（原错误：只有function(没有end）
coroutine.wrap(function()
    -- 这里可加Punish的触发逻辑（比如Punish(game.Players.SomePlayer)），保留原函数结构
end)()
