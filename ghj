-- 融合脚本：使用F3X创建云朵并添加全服可见的粒子效果
local Player = game.Players.LocalPlayer
local char = Player.Character or Player.CharacterAdded:Wait()

-- 查找F3X工具
local tool
for _, v in Player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
        break
    end
end

if not tool then
    for _, v in game.ReplicatedStorage:GetDescendants() do
        if v.Name == "SyncAPI" then
            tool = v.Parent
            break
        end
    end
end

if not tool then
    warn("F3X工具未找到！请确保您拥有F3X建筑工具。")
    return
end

local remote = tool.SyncAPI.ServerEndpoint

-- F3X API函数
function InvokeF3X(args)
    remote:InvokeServer(unpack(args))
end

function SetCollision(part, boolean)
    local args = {"SyncCollision", {{Part = part, CanCollide = boolean}}}
    InvokeF3X(args)
end

function SetAnchor(boolean, part)
    local args = {"SyncAnchor", {{Part = part, Anchored = boolean}}}
    InvokeF3X(args)
end

function CreatePart(cf, parent)
    local args = {"CreatePart", "Normal", cf, parent}
    InvokeF3X(args)
end

function AddMesh(part)
    local args = {"CreateMeshes", {{Part = part}}}
    InvokeF3X(args)
end

function SetMesh(part, meshid)
    local args = {"SyncMesh", {{Part = part, MeshId = "rbxassetid://" .. meshid}}}
    InvokeF3X(args)
end

function MeshResize(part, size)
    local args = {"SyncMesh", {{Part = part, Scale = size}}}
    InvokeF3X(args)
end

function SetColor(part, color)
    local args = {"SyncColor", {{Part = part, Color = color, UnionColoring = false}}}
    InvokeF3X(args)
end

function MovePart(part, cf)
    local args = {"SyncMove", {{Part = part, CFrame = cf}}}
    InvokeF3X(args)
end

function SetTransparency(part, transparency)
    local args = {"SyncTransparency", {{Part = part, Transparency = transparency}}}
    InvokeF3X(args)
end

-- 创建粒子效果的函数
function CreateParticleEffect(part)
    -- 方法1: 使用F3X创建粒子发射器
    local particleArgs = {
        "CreateParticleEmitter",
        {
            Part = part,
            Enabled = true,
            Rate = 30,
            Speed = NumberRange.new(3, 5),
            Size = NumberSequence.new(0.75),
            Texture = "rbxassetid://331959655",
            Transparency = NumberSequence.new(0.5),
            Acceleration = Vector3.new(0, -20, 0),
            EmissionDirection = Enum.NormalId.Bottom,
            Rotation = NumberRange.new(0, 360),
            RotSpeed = NumberRange.new(0, 15),
            VelocitySpread = 80,
            Lifetime = NumberRange.new(2, 4),
            SpreadAngle = Vector2.new(80, 80),
            Color = ColorSequence.new(Color3.new(1, 1, 1))
        }
    }
    
    -- 尝试使用F3X创建粒子效果
    local success, error = pcall(function()
        InvokeF3X(particleArgs)
    end)
    
    -- 如果F3X粒子效果失败，使用备选方案
    if not success then
        warn("F3X粒子效果创建失败: " .. tostring(error))
        warn("使用备选方案创建粒子效果...")
        
        -- 备选方案：创建多个小零件模拟粒子效果
        CreateParticleAlternative(part)
    end
end

-- 备选方案：使用多个小零件模拟粒子效果
function CreateParticleAlternative(cloudPart)
    for i = 1, 10 do
        local offset = Vector3.new(
            math.random(-5, 5),
            math.random(-2, 0),
            math.random(-5, 5)
        )
        
        local particleCf = cloudPart.CFrame + offset
        
        -- 创建粒子零件
        CreatePart(particleCf, workspace)
        
        -- 等待零件创建
        wait(0.05)
        
        -- 查找并设置粒子零件属性
        for _, part in workspace:GetDescendants() do
            if part:IsA("BasePart") and not part:IsDescendantOf(char) and 
               (part.Position - particleCf.Position).Magnitude < 2 then
                
                SetAnchor(true, part)
                SetCollision(part, false)
                SetColor(part, Color3.new(1, 1, 1)) -- 白色粒子
                SetTransparency(part, 0.5)
                
                -- 添加球体网格模拟粒子
                AddMesh(part)
                local meshArgs = {"SyncMesh", {{Part = part, MeshType = Enum.MeshType.Sphere}}}
                InvokeF3X(meshArgs)
                
                -- 设置小尺寸
                local sizeArgs = {"SyncResize", {{Part = part, Size = Vector3.new(0.3, 0.3, 0.3)}}}
                InvokeF3X(sizeArgs)
                
                -- 让粒子跟随云朵移动
                game:GetService("RunService").Heartbeat:Connect(function()
                    if cloudPart and cloudPart.Parent and part and part.Parent then
                        local newPos = cloudPart.Position + offset
                        MovePart(part, CFrame.new(newPos))
                    end
                end)
                
                break
            end
        end
    end
end

-- 创建云朵函数
function CreateCloud()
    local head = char:WaitForChild("Head")
    local cf = head.CFrame + Vector3.new(0, 20, 0)
    
    -- 使用F3X创建云朵零件
    CreatePart(cf, workspace)
    
    task.spawn(function()
        local cloudPart
        local attempts = 0
        repeat 
            task.wait(0.1)
            attempts = attempts + 1
            -- 查找新创建的零件
            for _, v in workspace:GetDescendants() do
                if v:IsA("BasePart") and not v:IsDescendantOf(char) then
                    -- 检查是否是最近创建的零件
                    if (v.Position - cf.Position).Magnitude < 10 then
                        cloudPart = v
                        break
                    end
                end
            end
        until cloudPart or attempts > 50
        
        if not cloudPart then
            warn("未能找到创建的云朵零件")
            return
        end
        
        -- 设置云朵属性
        SetAnchor(true, cloudPart)
        SetCollision(cloudPart, false)
        SetColor(cloudPart, BrickColor.new(333).Color)
        SetTransparency(cloudPart, 0.3) -- 半透明云朵
        AddMesh(cloudPart)
        SetMesh(cloudPart, "111820358")
        MeshResize(cloudPart, Vector3.new(8, 8, 8))
        
        -- 使用F3X添加粒子效果
        wait(0.5) -- 等待零件完全创建
        CreateParticleEffect(cloudPart)
        
        -- 让云朵跟随玩家
        local followConnection
        followConnection = game:GetService("RunService").Heartbeat:Connect(function()
            if char and char:FindFirstChild("Head") and cloudPart and cloudPart.Parent then
                MovePart(cloudPart, char.Head.CFrame + Vector3.new(0, 20, 0))
            else
                -- 如果角色或零件不存在，断开连接
                if followConnection then
                    followConnection:Disconnect()
                end
            end
        end)
        
        print("云朵创建成功！带有全服可见的粒子效果")
    end)
end

-- 执行创建云朵
CreateCloud()

-- 添加重新创建云朵的功能
local UserInputService = game:GetService("UserInputService")
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    
    if input.KeyCode == Enum.KeyCode.R then
        -- 按R键重新创建云朵
        CreateCloud()
    end
end)

print("云朵脚本已加载！按R键可以重新创建云朵")
